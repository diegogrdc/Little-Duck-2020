 mod littleduck_y {
    #![allow(clippy::type_complexity)]
    #![allow(clippy::unnecessary_wraps)]

    #[allow(unused_imports)]
    use ::lrpar::Lexeme;
#[allow(dead_code)] const __GRM_DATA: &[u8] = &[20,0,0,0,20,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,94,8,0,0,0,0,0,0,0,80,114,111,103,114,97,109,97,9,0,0,0,0,0,0,0,80,114,111,103,114,97,109,97,50,4,0,0,0,0,0,0,0,86,97,114,115,5,0,0,0,0,0,0,0,86,97,114,115,50,6,0,0,0,0,0,0,0,66,108,111,113,117,101,9,0,0,0,0,0,0,0,69,115,116,97,116,117,116,111,115,8,0,0,0,0,0,0,0,69,115,116,97,116,117,116,111,9,0,0,0,0,0,0,0,67,111,110,100,105,99,105,111,110,10,0,0,0,0,0,0,0,65,115,105,103,110,97,99,105,111,110,9,0,0,0,0,0,0,0,69,115,99,114,105,116,117,114,97,10,0,0,0,0,0,0,0,69,115,99,114,105,116,117,114,97,50,4,0,0,0,0,0,0,0,84,105,112,111,9,0,0,0,0,0,0,0,69,120,112,114,101,115,105,111,110,3,0,0,0,0,0,0,0,69,120,112,3,0,0,0,0,0,0,0,67,109,112,7,0,0,0,0,0,0,0,84,101,114,109,105,110,111,6,0,0,0,0,0,0,0,70,97,99,116,111,114,7,0,0,0,0,0,0,0,70,97,99,116,111,114,50,6,0,0,0,0,0,0,0,86,97,114,99,116,101,27,0,0,0,0,0,0,0,1,7,0,0,0,0,0,0,0,80,82,79,71,82,65,77,1,2,0,0,0,0,0,0,0,73,68,1,9,0,0,0,0,0,0,0,83,69,77,73,67,79,76,79,78,1,3,0,0,0,0,0,0,0,86,65,82,1,5,0,0,0,0,0,0,0,67,79,76,79,78,1,11,0,0,0,0,0,0,0,76,69,70,84,66,82,65,67,75,69,84,1,12,0,0,0,0,0,0,0,82,73,71,84,72,66,82,65,67,75,69,84,1,2,0,0,0,0,0,0,0,73,70,1,15,0,0,0,0,0,0,0,76,69,70,84,80,65,82,69,78,84,72,69,83,69,83,1,16,0,0,0,0,0,0,0,82,73,71,72,84,80,65,82,69,78,84,72,69,83,69,83,1,4,0,0,0,0,0,0,0,69,76,83,69,1,9,0,0,0,0,0,0,0,69,81,85,65,76,83,73,71,78,1,5,0,0,0,0,0,0,0,80,82,73,78,84,1,5,0,0,0,0,0,0,0,67,79,77,77,65,1,6,0,0,0,0,0,0,0,67,84,69,83,84,82,1,3,0,0,0,0,0,0,0,73,78,84,1,5,0,0,0,0,0,0,0,70,76,79,65,84,1,8,0,0,0,0,0,0,0,80,76,85,83,83,73,71,78,1,9,0,0,0,0,0,0,0,77,73,78,85,83,83,73,71,78,1,11,0,0,0,0,0,0,0,71,82,69,65,84,69,82,83,73,71,78,1,8,0,0,0,0,0,0,0,76,69,83,83,83,73,71,78,1,12,0,0,0,0,0,0,0,78,79,84,69,81,85,65,76,83,73,71,78,1,18,0,0,0,0,0,0,0,77,85,76,84,73,80,76,73,67,65,84,73,79,78,83,73,71,78,1,12,0,0,0,0,0,0,0,68,73,86,73,83,73,79,78,83,73,71,78,1,4,0,0,0,0,0,0,0,67,84,69,73,1,4,0,0,0,0,0,0,0,67,84,69,70,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,1,7,0,0,0,0,0,0,0,80,82,79,71,82,65,77,1,2,0,0,0,0,0,0,0,73,68,1,9,0,0,0,0,0,0,0,83,69,77,73,67,79,76,79,78,1,3,0,0,0,0,0,0,0,86,65,82,1,5,0,0,0,0,0,0,0,67,79,76,79,78,1,11,0,0,0,0,0,0,0,76,69,70,84,66,82,65,67,75,69,84,1,12,0,0,0,0,0,0,0,82,73,71,84,72,66,82,65,67,75,69,84,1,2,0,0,0,0,0,0,0,73,70,1,15,0,0,0,0,0,0,0,76,69,70,84,80,65,82,69,78,84,72,69,83,69,83,1,16,0,0,0,0,0,0,0,82,73,71,72,84,80,65,82,69,78,84,72,69,83,69,83,1,4,0,0,0,0,0,0,0,69,76,83,69,1,9,0,0,0,0,0,0,0,69,81,85,65,76,83,73,71,78,1,5,0,0,0,0,0,0,0,80,82,73,78,84,1,5,0,0,0,0,0,0,0,67,79,77,77,65,1,6,0,0,0,0,0,0,0,67,84,69,83,84,82,1,3,0,0,0,0,0,0,0,73,78,84,1,5,0,0,0,0,0,0,0,70,76,79,65,84,1,8,0,0,0,0,0,0,0,80,76,85,83,83,73,71,78,1,9,0,0,0,0,0,0,0,77,73,78,85,83,83,73,71,78,1,11,0,0,0,0,0,0,0,71,82,69,65,84,69,82,83,73,71,78,1,8,0,0,0,0,0,0,0,76,69,83,83,83,73,71,78,1,12,0,0,0,0,0,0,0,78,79,84,69,81,85,65,76,83,73,71,78,1,18,0,0,0,0,0,0,0,77,85,76,84,73,80,76,73,67,65,84,73,79,78,83,73,71,78,1,12,0,0,0,0,0,0,0,68,73,86,73,83,73,79,78,83,73,71,78,1,4,0,0,0,0,0,0,0,67,84,69,73,1,4,0,0,0,0,0,0,0,67,84,69,70,0,27,0,0,0,26,0,0,0,44,0,0,0,43,0,0,0,44,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,4,0,0,0,5,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,12,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,12,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,1,0,0,0,6,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,5,0,0,0,1,0,0,0,6,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,6,0,0,0,0,0,0,0,1,0,0,0,7,0,0,0,1,0,0,0,8,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,2,0,0,0,8,0,0,0,0,0,0,0,1,0,0,0,7,0,0,0,1,0,0,0,8,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,10,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,2,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,11,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,2,0,0,0,5,0,0,0,0,0,0,0,1,0,0,0,12,0,0,0,1,0,0,0,8,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,9,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,13,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,1,0,0,0,13,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,16,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,17,0,0,0,0,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,19,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,20,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,21,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,0,0,22,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,0,0,23,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,8,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,9,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,17,0,0,0,0,0,0,0,19,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,24,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,25,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,20,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,43,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,2,0,0,0,0,0,0,0,7,0,0,0,8,0,0,0,2,0,0,0,0,0,0,0,9,0,0,0,10,0,0,0,3,0,0,0,0,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,2,0,0,0,0,0,0,0,14,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,0,0,0,0,17,0,0,0,4,0,0,0,0,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,2,0,0,0,0,0,0,0,22,0,0,0,23,0,0,0,2,0,0,0,0,0,0,0,24,0,0,0,25,0,0,0,3,0,0,0,0,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,3,0,0,0,0,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,3,0,0,0,0,0,0,0,32,0,0,0,33,0,0,0,34,0,0,0,2,0,0,0,0,0,0,0,35,0,0,0,36,0,0,0,3,0,0,0,0,0,0,0,37,0,0,0,38,0,0,0,39,0,0,0,3,0,0,0,0,0,0,0,40,0,0,0,41,0,0,0,42,0,0,0,44,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,5,0,0,0,5,0,0,0,6,0,0,0,6,0,0,0,7,0,0,0,7,0,0,0,7,0,0,0,8,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,12,0,0,0,12,0,0,0,13,0,0,0,13,0,0,0,14,0,0,0,14,0,0,0,14,0,0,0,15,0,0,0,15,0,0,0,15,0,0,0,16,0,0,0,16,0,0,0,16,0,0,0,17,0,0,0,17,0,0,0,18,0,0,0,18,0,0,0,18,0,0,0,19,0,0,0,19,0,0,0,19,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,0,0,1,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,0,0,0,];
#[allow(dead_code)] const __STABLE_DATA: &[u8] = &[81,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,92,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,114,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,101,0,0,0,0,0,0,0,111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,110,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,198,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,114,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,132,0,0,0,0,0,0,0,154,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,238,0,0,0,0,0,0,0,252,0,0,0,0,0,0,0,7,1,0,0,0,0,0,0,9,1,0,0,0,0,0,0,238,0,0,0,0,0,0,0,136,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,119,0,0,0,0,0,0,0,211,0,0,0,0,0,0,0,224,0,0,0,0,0,0,0,176,0,0,0,0,0,0,0,116,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,158,0,0,0,0,0,0,0,9,1,0,0,0,0,0,0,33,1,0,0,0,0,0,0,225,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,180,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,202,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,254,255,255,239,255,255,255,255,255,255,246,255,255,127,253,255,255,254,255,255,247,188,255,255,255,255,127,255,255,255,251,254,255,255,250,255,255,191,255,255,223,243,254,255,127,255,255,255,223,255,191,231,253,255,61,239,255,255,247,255,255,254,254,255,122,222,255,223,243,254,255,255,255,255,245,255,255,255,255,207,255,251,251,255,235,121,255,127,191,111,62,251,253,243,217,239,159,207,239,255,255,239,255,255,127,255,255,255,251,255,255,223,239,14,248,126,119,192,251,255,255,217,255,255,207,253,238,128,247,251,231,115,191,59,224,251,221,1,223,239,14,248,127,247,255,255,187,255,255,223,255,255,253,238,224,239,119,31,127,255,255,255,255,253,255,239,254,255,255,126,119,192,247,187,3,222,239,159,207,126,255,124,254,247,255,191,223,55,159,253,190,249,220,255,255,127,191,127,62,251,253,243,217,239,159,207,126,255,124,246,251,231,179,223,63,159,61,239,255,255,254,255,255,247,255,255,247,187,131,191,223,29,252,253,238,128,255,247,255,255,191,255,255,61,239,255,223,239,62,254,126,247,241,247,187,255,191,191,255,255,158,247,255,127,255,255,127,255,255,255,61,239,255,7,0,0,0,0,0,0,60,1,0,0,0,0,0,0,45,0,0,0,0,0,0,0,146,228,72,209,192,82,142,2,88,170,81,36,140,37,13,69,178,100,201,146,165,26,25,34,96,67,132,3,73,150,44,89,73,132,13,27,146,2,245,241,146,36,73,146,108,12,240,32,12,3,82,4,73,146,36,73,10,50,100,8,242,208,77,132,130,4,9,146,33,32,131,160,210,40,49,85,45,154,32,65,152,48,97,170,77,184,80,38,50,101,202,68,156,46,166,178,169,64,148,41,83,166,76,153,194,133,168,82,157,36,184,168,148,40,23,90,138,137,202,233,23,85,162,68,137,18,37,74,21,170,42,22,12,168,162,156,170,84,88,177,160,42,164,10,60,169,82,165,74,149,42,85,120,2,0,0,128,144,160,78,18,2,0,128,39,0,66,132,228,201,147,39,79,158,60,121,9,0,0,0,70,0,0,208,8,0,0,154,0,24,49,162,38,77,154,52,105,210,164,201,0,0,0,232,0,0,192,145,0,0,56,2,160,67,135,35,28,57,114,228,200,145,35,29,0,0,224,3,0,0,53,142,2,160,6,128,15,31,106,0,164,70,141,154,116,237,124,24,70,17,0,67,0,0,0,48,140,34,67,134,12,25,50,100,34,49,161,204,40,2,0,192,0,98,50,41,82,164,72,145,145,0,216,73,37,6,0,0,58,1,176,83,47,95,188,70,216,1,32,71,15,0,63,165,177,3,64,142,30,0,126,236,163,71,143,31,63,0,228,216,70,143,30,63,126,228,200,145,13,0,0,0,0,0,0,224,0,0,0,220,0,0,0,192,0,0,220,184,113,3,0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,1,0,0,16,0,0,0,0,0,0,9,0,0,128,2,0,0,1,0,0,8,67,0,0,0,0,128,0,0,0,4,1,0,0,5,0,0,64,0,0,32,12,1,0,128,0,0,0,32,0,64,24,2,0,194,16,0,0,8,0,0,1,1,0,133,33,0,32,12,1,0,0,0,0,10,0,0,0,0,48,0,4,4,0,20,134,0,128,64,144,193,4,2,12,38,16,96,48,16,0,0,16,0,0,128,0,0,0,4,0,0,32,16,241,7,129,136,63,4,0,0,38,0,0,48,2,17,127,8,4,24,140,64,196,31,4,34,254,32,16,241,7,128,8,0,0,68,0,0,32,0,0,2,17,31,16,136,224,128,0,0,0,0,2,0,16,1,0,0,129,136,63,8,68,252,33,16,96,48,129,0,131,1,8,0,64,32,200,96,2,65,6,35,0,0,128,64,128,193,4,2,12,38,16,96,48,129,0,131,9,4,24,76,32,192,96,194,16,0,0,1,0,0,8,0,0,8,68,124,64,32,226,3,2,17,127,0,8,0,0,64,0,0,194,16,0,32,16,193,1,129,8,14,8,68,0,64,64,0,0,97,8,0,128,0,0,128,0,0,0,194,16,0,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,84,6,0,0,0,0,0,0,26,0,0,0,0,0,0,0,253,255,255,255,255,255,255,255,255,255,211,255,255,254,255,63,248,255,255,255,255,255,255,253,255,255,255,255,255,255,127,248,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,239,255,255,255,254,255,255,255,255,255,255,151,240,255,9,255,159,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127,255,255,247,255,255,255,191,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127,255,255,255,255,255,255,254,255,255,255,255,255,255,255,255,240,255,15,255,255,255,127,9,255,151,240,255,255,255,191,240,255,11,255,255,255,255,255,255,255,255,255,11,255,255,255,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,15,0,0,0,0,0,89,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,34,148,6,130,161,72,12,0,153,92,158,23,203,210,130,84,50,185,102,47,214,231,40,26,100,114,1,95,44,26,82,52,76,52,50,185,134,47,152,104,23,244,38,26,153,92,205,87,162,145,201,5,80,138,70,38,92,0,166,104,100,114,1,150,153,136,144,74,68,35,26,153,0,0,0,162,145,169,40,26,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,13,0,0,0,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,32,0,0,0,0,0,8,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,128,0,0,0,0,0,0,0,2,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,64,0,0,16,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,128,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,8,0,0,0,0,64,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,32,0,0,0,0,0,4,0,0,0,0,128,0,0,0,32,0,0,0,0,128,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,8,0,0,0,0,32,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,1,0,0,16,0,0,0,0,0,0,8,0,0,128,2,0,0,1,0,0,8,67,0,0,0,0,0,0,0,0,0,1,0,0,5,0,0,0,0,0,32,12,1,0,128,0,0,0,32,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,48,0,0,0,0,0,0,0,128,64,144,193,4,2,12,38,16,96,48,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,38,0,0,48,0,0,96,8,4,24,12,0,0,0,0,0,0,0,0,0,0,0,8,0,0,64,0,0,32,0,0,0,0,3,0,0,224,128,0,0,0,0,2,0,16,0,0,0,0,0,0,0,0,0,32,16,96,48,129,0,131,1,8,0,64,32,200,96,2,65,6,35,0,0,128,64,128,193,4,2,12,6,0,0,0,0,0,0,0,0,0,64,32,192,96,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,64,0,0,0,0,0,128,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,128,137,61,163,135,3,12,112,253,47,1,0,0,0,0,0,44,0,0,0,27,0,0,0,0,2,0,];

    #[allow(dead_code)]
    pub fn parse<'lexer, 'input: 'lexer>(
        lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>)
          -> (::std::option::Option<Result<String, ()>>, ::std::vec::Vec<::lrpar::LexParseError<lrlex::lexemes::DefaultLexeme, u32>>)
    {
        let (grm, stable) = ::lrpar::ctbuilder::_reconstitute(__GRM_DATA, __STABLE_DATA);
        #[allow(clippy::type_complexity)]
        let actions: ::std::vec::Vec<&dyn Fn(::cfgrammar::RIdx<u32>,
                       &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                       ::lrpar::Span,
                       ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                       ())
                    -> __GtActionsKind<'input>> = ::std::vec![&__gt_wrapper_0,
                        &__gt_wrapper_1,
                        &__gt_wrapper_2,
                        &__gt_wrapper_3,
                        &__gt_wrapper_4,
                        &__gt_wrapper_5,
                        &__gt_wrapper_6,
                        &__gt_wrapper_7,
                        &__gt_wrapper_8,
                        &__gt_wrapper_9,
                        &__gt_wrapper_10,
                        &__gt_wrapper_11,
                        &__gt_wrapper_12,
                        &__gt_wrapper_13,
                        &__gt_wrapper_14,
                        &__gt_wrapper_15,
                        &__gt_wrapper_16,
                        &__gt_wrapper_17,
                        &__gt_wrapper_18,
                        &__gt_wrapper_19,
                        &__gt_wrapper_20,
                        &__gt_wrapper_21,
                        &__gt_wrapper_22,
                        &__gt_wrapper_23,
                        &__gt_wrapper_24,
                        &__gt_wrapper_25,
                        &__gt_wrapper_26,
                        &__gt_wrapper_27,
                        &__gt_wrapper_28,
                        &__gt_wrapper_29,
                        &__gt_wrapper_30,
                        &__gt_wrapper_31,
                        &__gt_wrapper_32,
                        &__gt_wrapper_33,
                        &__gt_wrapper_34,
                        &__gt_wrapper_35,
                        &__gt_wrapper_36,
                        &__gt_wrapper_37,
                        &__gt_wrapper_38,
                        &__gt_wrapper_39,
                        &__gt_wrapper_40,
                        &__gt_wrapper_41,
                        &__gt_wrapper_42,
                        &__gt_wrapper_43];

        match ::lrpar::RTParserBuilder::new(&grm, &stable)
            .recoverer(::lrpar::RecoveryKind::CPCTPlus)
            .parse_actions(lexer, &actions, ()) {
                (Some(__GtActionsKind::Ak1(x)), y) => (Some(x), y),
                (None, y) => (None, y),
                _ => unreachable!()
        }
    }

    #[allow(dead_code)]
    pub const R_PROGRAMA: u32 = 1;
    #[allow(dead_code)]
    pub const R_PROGRAMA2: u32 = 2;
    #[allow(dead_code)]
    pub const R_VARS: u32 = 3;
    #[allow(dead_code)]
    pub const R_VARS2: u32 = 4;
    #[allow(dead_code)]
    pub const R_BLOQUE: u32 = 5;
    #[allow(dead_code)]
    pub const R_ESTATUTOS: u32 = 6;
    #[allow(dead_code)]
    pub const R_ESTATUTO: u32 = 7;
    #[allow(dead_code)]
    pub const R_CONDICION: u32 = 8;
    #[allow(dead_code)]
    pub const R_ASIGNACION: u32 = 9;
    #[allow(dead_code)]
    pub const R_ESCRITURA: u32 = 10;
    #[allow(dead_code)]
    pub const R_ESCRITURA2: u32 = 11;
    #[allow(dead_code)]
    pub const R_TIPO: u32 = 12;
    #[allow(dead_code)]
    pub const R_EXPRESION: u32 = 13;
    #[allow(dead_code)]
    pub const R_EXP: u32 = 14;
    #[allow(dead_code)]
    pub const R_CMP: u32 = 15;
    #[allow(dead_code)]
    pub const R_TERMINO: u32 = 16;
    #[allow(dead_code)]
    pub const R_FACTOR: u32 = 17;
    #[allow(dead_code)]
    pub const R_FACTOR2: u32 = 18;
    #[allow(dead_code)]
    pub const R_VARCTE: u32 = 19;
    const __GT_EPP: &[::std::option::Option<&str>] = &[Some("PROGRAM"), Some("ID"), Some("SEMICOLON"), Some("VAR"), Some("COLON"), Some("LEFTBRACKET"), Some("RIGTHBRACKET"), Some("IF"), Some("LEFTPARENTHESES"), Some("RIGHTPARENTHESES"), Some("ELSE"), Some("EQUALSIGN"), Some("PRINT"), Some("COMMA"), Some("CTESTR"), Some("INT"), Some("FLOAT"), Some("PLUSSIGN"), Some("MINUSSIGN"), Some("GREATERSIGN"), Some("LESSSIGN"), Some("NOTEQUALSIGN"), Some("MULTIPLICATIONSIGN"), Some("DIVISIONSIGN"), Some("CTEI"), Some("CTEF"), None];

    /// Return the %epp entry for token `tidx` (where `None` indicates "the token has no
    /// pretty-printed value"). Panics if `tidx` doesn't exist.
    #[allow(dead_code)]
    pub fn token_epp<'a>(tidx: ::cfgrammar::TIdx<u32>) -> ::std::option::Option<&'a str> {
        __GT_EPP[usize::from(tidx)]
    }

    // Wrappers

    fn __gt_wrapper_0<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak2(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak1(__gt_action_0(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_1<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak2(__gt_action_1(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_2<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak3(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak2(__gt_action_2(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_3<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak3(__gt_action_3(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_4<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_4(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_5<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak12(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_5(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5))
    }

    fn __gt_wrapper_6<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak12(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_6(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_7<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak6(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak5(__gt_action_7(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_8<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak5(__gt_action_8(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_9<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak7(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak6(__gt_action_9(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_10<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak6(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak7(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak6(__gt_action_10(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_11<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak9(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_11(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_12<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak8(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_12(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_13<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak10(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_13(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_14<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_6 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak8(__gt_action_14(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5, __gt_arg_6))
    }

    fn __gt_wrapper_15<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_6 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_7 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_8 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak8(__gt_action_15(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5, __gt_arg_6, __gt_arg_7, __gt_arg_8))
    }

    fn __gt_wrapper_16<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak9(__gt_action_16(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_17<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak10(__gt_action_17(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5))
    }

    fn __gt_wrapper_18<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_18(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_19<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_19(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_20<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_20(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_21<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_21(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_22<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak12(__gt_action_22(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_23<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak12(__gt_action_23(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_24<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak13(__gt_action_24(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_25<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak15(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak13(__gt_action_25(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_26<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_26(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_27<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_27(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_28<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_28(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_29<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_29(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_30<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_30(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_31<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_31(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_32<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_32(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_33<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_33(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_34<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_34(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_35<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak17(__gt_action_35(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_36<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak18(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak17(__gt_action_36(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_37<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_37(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_38<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_38(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_39<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_39(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_40<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_40(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_41<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_41(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_42<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_42(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_43<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let _ = ();
        unreachable!()
    }

    #[allow(dead_code)]
    enum __GtActionsKind<'input> {
        Ak1(Result<String, ()>),
        Ak2(Result<String, ()>),
        Ak3(Result<String, ()>),
        Ak4(Result<String, ()>),
        Ak5(Result<String, ()>),
        Ak6(Result<String, ()>),
        Ak7(Result<String, ()>),
        Ak8(Result<String, ()>),
        Ak9(Result<String, ()>),
        Ak10(Result<String, ()>),
        Ak11(Result<String, ()>),
        Ak12(Result<String, ()>),
        Ak13(Result<String, ()>),
        Ak14(Result<String, ()>),
        Ak15(Result<String, ()>),
        Ak16(Result<String, ()>),
        Ak17(Result<String, ()>),
        Ak18(Result<String, ()>),
        Ak19(Result<String, ()>),
    ___GtActionsKindHidden(::std::marker::PhantomData<&'input ()>)
    }


// User code from the program section


    // User actions

    // Programa
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_0<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_4: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Programa2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_1<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Programa2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_2<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_3<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_4<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_5<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_6<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Bloque
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_7<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Bloque
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_8<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatutos
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_9<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatutos
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_10<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_11<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_12<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_13<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Condicion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_14<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>,
                     mut __gt_arg_6: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Condicion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_15<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>,
                     mut __gt_arg_6: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_7: Result<String, ()>,
                     mut __gt_arg_8: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Asignacion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_16<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_17<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_18<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_19<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_20<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_21<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Tipo
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_22<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Tipo
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_23<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Expresion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_24<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Expresion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_25<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_26<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_27<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_28<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_29<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_30<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_31<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_32<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_33<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_34<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_35<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_36<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_37<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_38<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_39<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_40<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_41<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_42<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

}


/* CACHE INFORMATION
   Build time: "2022-03-09T17:17:51.897630+00:00"
   Grammar path: Some("/Users/diegogarciarodriguezdelcampo/Desktop/8vo/Compis/LittleDuck2020/GRMTOOLS/littleduck/src/littleduck.y")
   Mod name: None
   Recoverer: CPCTPlus
   YaccKind: Some(Grmtools)
   Visibility: ""
   Error on conflicts: true
   0 'PROGRAM'
   1 'ID'
   2 'SEMICOLON'
   3 'VAR'
   4 'COLON'
   5 'LEFTBRACKET'
   6 'RIGTHBRACKET'
   7 'IF'
   8 'LEFTPARENTHESES'
   9 'RIGHTPARENTHESES'
   10 'ELSE'
   11 'EQUALSIGN'
   12 'PRINT'
   13 'COMMA'
   14 'CTESTR'
   15 'INT'
   16 'FLOAT'
   17 'PLUSSIGN'
   18 'MINUSSIGN'
   19 'GREATERSIGN'
   20 'LESSSIGN'
   21 'NOTEQUALSIGN'
   22 'MULTIPLICATIONSIGN'
   23 'DIVISIONSIGN'
   24 'CTEI'
   25 'CTEF'
   26 <unknown>
*/

 mod littleduck_y {
    #![allow(clippy::type_complexity)]
    #![allow(clippy::unnecessary_wraps)]

    #[allow(unused_imports)]
    use ::lrpar::Lexeme;
#[allow(dead_code)] const __GRM_DATA: &[u8] = &[20,0,0,0,20,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,94,8,0,0,0,0,0,0,0,80,114,111,103,114,97,109,97,9,0,0,0,0,0,0,0,80,114,111,103,114,97,109,97,50,4,0,0,0,0,0,0,0,86,97,114,115,5,0,0,0,0,0,0,0,86,97,114,115,50,6,0,0,0,0,0,0,0,66,108,111,113,117,101,9,0,0,0,0,0,0,0,69,115,116,97,116,117,116,111,115,8,0,0,0,0,0,0,0,69,115,116,97,116,117,116,111,9,0,0,0,0,0,0,0,67,111,110,100,105,99,105,111,110,10,0,0,0,0,0,0,0,65,115,105,103,110,97,99,105,111,110,9,0,0,0,0,0,0,0,69,115,99,114,105,116,117,114,97,10,0,0,0,0,0,0,0,69,115,99,114,105,116,117,114,97,50,4,0,0,0,0,0,0,0,84,105,112,111,9,0,0,0,0,0,0,0,69,120,112,114,101,115,105,111,110,3,0,0,0,0,0,0,0,69,120,112,3,0,0,0,0,0,0,0,67,109,112,7,0,0,0,0,0,0,0,84,101,114,109,105,110,111,6,0,0,0,0,0,0,0,70,97,99,116,111,114,7,0,0,0,0,0,0,0,70,97,99,116,111,114,50,6,0,0,0,0,0,0,0,86,97,114,99,116,101,27,0,0,0,0,0,0,0,1,7,0,0,0,0,0,0,0,80,82,79,71,82,65,77,1,2,0,0,0,0,0,0,0,73,68,1,9,0,0,0,0,0,0,0,83,69,77,73,67,79,76,79,78,1,3,0,0,0,0,0,0,0,86,65,82,1,5,0,0,0,0,0,0,0,67,79,77,77,65,1,5,0,0,0,0,0,0,0,67,79,76,79,78,1,11,0,0,0,0,0,0,0,76,69,70,84,66,82,65,67,75,69,84,1,12,0,0,0,0,0,0,0,82,73,71,84,72,66,82,65,67,75,69,84,1,2,0,0,0,0,0,0,0,73,70,1,15,0,0,0,0,0,0,0,76,69,70,84,80,65,82,69,78,84,72,69,83,69,83,1,16,0,0,0,0,0,0,0,82,73,71,72,84,80,65,82,69,78,84,72,69,83,69,83,1,4,0,0,0,0,0,0,0,69,76,83,69,1,9,0,0,0,0,0,0,0,69,81,85,65,76,83,73,71,78,1,5,0,0,0,0,0,0,0,80,82,73,78,84,1,6,0,0,0,0,0,0,0,67,84,69,83,84,82,1,3,0,0,0,0,0,0,0,73,78,84,1,5,0,0,0,0,0,0,0,70,76,79,65,84,1,8,0,0,0,0,0,0,0,80,76,85,83,83,73,71,78,1,9,0,0,0,0,0,0,0,77,73,78,85,83,83,73,71,78,1,11,0,0,0,0,0,0,0,71,82,69,65,84,69,82,83,73,71,78,1,8,0,0,0,0,0,0,0,76,69,83,83,83,73,71,78,1,12,0,0,0,0,0,0,0,78,79,84,69,81,85,65,76,83,73,71,78,1,18,0,0,0,0,0,0,0,77,85,76,84,73,80,76,73,67,65,84,73,79,78,83,73,71,78,1,12,0,0,0,0,0,0,0,68,73,86,73,83,73,79,78,83,73,71,78,1,4,0,0,0,0,0,0,0,67,84,69,73,1,4,0,0,0,0,0,0,0,67,84,69,70,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,1,7,0,0,0,0,0,0,0,80,82,79,71,82,65,77,1,2,0,0,0,0,0,0,0,73,68,1,9,0,0,0,0,0,0,0,83,69,77,73,67,79,76,79,78,1,3,0,0,0,0,0,0,0,86,65,82,1,5,0,0,0,0,0,0,0,67,79,77,77,65,1,5,0,0,0,0,0,0,0,67,79,76,79,78,1,11,0,0,0,0,0,0,0,76,69,70,84,66,82,65,67,75,69,84,1,12,0,0,0,0,0,0,0,82,73,71,84,72,66,82,65,67,75,69,84,1,2,0,0,0,0,0,0,0,73,70,1,15,0,0,0,0,0,0,0,76,69,70,84,80,65,82,69,78,84,72,69,83,69,83,1,16,0,0,0,0,0,0,0,82,73,71,72,84,80,65,82,69,78,84,72,69,83,69,83,1,4,0,0,0,0,0,0,0,69,76,83,69,1,9,0,0,0,0,0,0,0,69,81,85,65,76,83,73,71,78,1,5,0,0,0,0,0,0,0,80,82,73,78,84,1,6,0,0,0,0,0,0,0,67,84,69,83,84,82,1,3,0,0,0,0,0,0,0,73,78,84,1,5,0,0,0,0,0,0,0,70,76,79,65,84,1,8,0,0,0,0,0,0,0,80,76,85,83,83,73,71,78,1,9,0,0,0,0,0,0,0,77,73,78,85,83,83,73,71,78,1,11,0,0,0,0,0,0,0,71,82,69,65,84,69,82,83,73,71,78,1,8,0,0,0,0,0,0,0,76,69,83,83,83,73,71,78,1,12,0,0,0,0,0,0,0,78,79,84,69,81,85,65,76,83,73,71,78,1,18,0,0,0,0,0,0,0,77,85,76,84,73,80,76,73,67,65,84,73,79,78,83,73,71,78,1,12,0,0,0,0,0,0,0,68,73,86,73,83,73,79,78,83,73,71,78,1,4,0,0,0,0,0,0,0,67,84,69,73,1,4,0,0,0,0,0,0,0,67,84,69,70,0,27,0,0,0,26,0,0,0,44,0,0,0,43,0,0,0,44,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,5,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,5,0,0,0,0,0,0,0,12,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,5,0,0,0,0,0,0,0,12,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,1,0,0,0,7,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,6,0,0,0,1,0,0,0,7,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,6,0,0,0,0,0,0,0,1,0,0,0,8,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,10,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,2,0,0,0,8,0,0,0,0,0,0,0,1,0,0,0,8,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,10,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,11,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,2,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,2,0,0,0,5,0,0,0,0,0,0,0,1,0,0,0,13,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,10,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,14,0,0,0,1,0,0,0,4,0,0,0,0,0,0,0,11,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,16,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,17,0,0,0,0,0,0,0,14,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,19,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,20,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,21,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,0,0,22,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,0,0,23,0,0,0,0,0,0,0,16,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,9,0,0,0,0,0,0,0,14,0,0,0,1,0,0,0,10,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,17,0,0,0,0,0,0,0,19,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,24,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,25,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,20,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,43,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,2,0,0,0,0,0,0,0,7,0,0,0,8,0,0,0,2,0,0,0,0,0,0,0,9,0,0,0,10,0,0,0,3,0,0,0,0,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,2,0,0,0,0,0,0,0,14,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,16,0,0,0,1,0,0,0,0,0,0,0,17,0,0,0,4,0,0,0,0,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,2,0,0,0,0,0,0,0,22,0,0,0,23,0,0,0,2,0,0,0,0,0,0,0,24,0,0,0,25,0,0,0,3,0,0,0,0,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,3,0,0,0,0,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,3,0,0,0,0,0,0,0,32,0,0,0,33,0,0,0,34,0,0,0,2,0,0,0,0,0,0,0,35,0,0,0,36,0,0,0,3,0,0,0,0,0,0,0,37,0,0,0,38,0,0,0,39,0,0,0,3,0,0,0,0,0,0,0,40,0,0,0,41,0,0,0,42,0,0,0,44,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,5,0,0,0,5,0,0,0,6,0,0,0,6,0,0,0,7,0,0,0,7,0,0,0,7,0,0,0,8,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,12,0,0,0,12,0,0,0,13,0,0,0,13,0,0,0,14,0,0,0,14,0,0,0,14,0,0,0,15,0,0,0,15,0,0,0,15,0,0,0,16,0,0,0,16,0,0,0,16,0,0,0,17,0,0,0,17,0,0,0,18,0,0,0,18,0,0,0,18,0,0,0,19,0,0,0,19,0,0,0,19,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,1,18,0,0,0,0,0,0,0,79,107,40,34,34,46,116,111,95,115,116,114,105,110,103,40,41,41,0,0,1,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,1,18,0,0,0,0,0,0,0,82,101,115,117,108,116,60,83,116,114,105,110,103,44,32,40,41,62,0,0,0,];
#[allow(dead_code)] const __STABLE_DATA: &[u8] = &[81,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,30,1,0,0,0,0,0,0,51,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,47,1,0,0,0,0,0,0,49,1,0,0,0,0,0,0,62,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,57,1,0,0,0,0,0,0,60,1,0,0,0,0,0,0,46,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,68,1,0,0,0,0,0,0,236,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,110,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,198,0,0,0,0,0,0,0,228,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,132,0,0,0,0,0,0,0,154,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,236,0,0,0,0,0,0,0,250,0,0,0,0,0,0,0,254,0,0,0,0,0,0,0,8,1,0,0,0,0,0,0,236,0,0,0,0,0,0,0,70,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,203,0,0,0,0,0,0,0,223,0,0,0,0,0,0,0,176,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,78,1,0,0,0,0,0,0,25,1,0,0,0,0,0,0,32,1,0,0,0,0,0,0,26,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,81,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,89,1,0,0,0,0,0,0,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,254,255,255,239,255,255,255,255,255,255,246,255,255,127,251,255,255,254,255,255,247,121,255,255,255,255,127,255,255,255,251,253,255,255,243,255,255,127,255,255,223,231,253,255,255,254,255,255,191,255,191,207,251,255,125,222,255,255,239,255,255,254,253,255,250,188,255,223,231,253,255,255,255,255,245,255,255,255,255,207,255,251,247,255,235,243,254,127,127,111,62,251,251,243,217,223,159,207,223,255,255,239,255,255,127,255,255,255,251,255,255,95,223,15,248,250,126,192,251,255,255,217,255,255,207,245,253,128,247,247,231,115,125,63,224,235,251,1,95,223,15,248,251,254,255,223,247,255,255,191,255,255,245,253,224,175,239,31,127,255,255,255,255,251,255,239,253,255,255,250,126,192,215,247,3,222,223,159,207,254,254,124,254,239,255,191,191,55,159,253,189,249,220,255,255,127,127,127,62,251,251,243,217,223,159,207,254,254,124,246,247,231,179,191,63,159,125,222,255,255,253,255,255,239,255,255,215,247,131,191,190,31,252,245,253,128,255,239,255,255,127,255,255,125,222,255,95,223,63,254,250,254,241,215,247,255,191,127,255,255,62,239,255,255,254,255,127,255,255,255,125,222,255,7,0,0,0,0,0,0,116,1,0,0,0,0,0,0,53,0,0,0,0,0,0,0,42,120,176,36,194,82,142,2,212,16,17,202,82,134,34,73,178,100,201,146,165,46,89,60,35,66,82,55,73,150,44,89,170,83,3,73,82,204,120,48,146,36,73,146,2,245,49,83,77,65,225,4,73,146,36,73,3,26,4,41,137,48,32,69,130,4,9,74,227,32,167,0,76,181,49,85,45,154,32,65,121,49,165,165,152,4,5,113,50,101,42,100,197,130,1,203,101,65,148,41,83,166,76,153,64,20,0,0,65,157,88,17,148,40,0,0,0,0,0,0,0,85,162,68,137,18,37,74,85,0,0,0,0,0,64,21,170,0,0,0,0,0,0,0,60,169,82,165,74,149,42,85,1,0,0,0,0,0,79,0,2,0,0,0,0,0,0,60,228,201,147,39,79,158,60,121,0,0,0,0,0,52,1,208,0,0,0,0,0,0,208,4,38,77,154,52,105,210,164,9,0,0,0,0,112,4,192,145,0,0,0,0,0,192,17,0,28,57,114,228,200,145,35,0,24,2,0,64,13,0,53,142,2,0,0,0,0,53,134,0,164,70,141,154,116,237,0,24,8,128,34,67,134,12,25,50,128,34,49,0,196,0,0,160,34,69,0,196,132,2,0,0,124,241,0,100,82,164,72,145,126,26,69,2,96,39,85,189,0,148,234,100,7,0,0,0,0,176,99,7,128,30,0,126,0,96,199,142,30,63,126,0,32,71,143,30,0,126,252,0,199,141,30,61,57,0,200,1,13,0,0,0,138,132,113,35,0,27,0,228,200,145,83,195,25,54,108,184,113,227,70,6,0,100,184,176,1,192,132,12,76,168,112,225,2,128,9,19,8,81,161,2,128,11,0,66,1,32,68,135,10,0,70,132,96,196,135,14,29,0,140,24,0,128,15,31,0,116,0,0,0,0,0,0,124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,1,0,0,16,0,0,0,0,0,0,9,0,0,128,4,0,0,1,0,0,8,134,0,0,0,0,128,0,0,0,4,2,0,0,12,0,0,128,0,0,32,24,2,0,0,1,0,0,64,0,64,48,4,0,130,33,0,0,16,0,0,1,2,0,5,67,0,32,24,2,0,0,0,0,10,0,0,0,0,48,0,4,8,0,20,12,1,128,128,144,193,4,4,12,38,32,96,48,32,0,0,16,0,0,128,0,0,0,4,0,0,160,32,240,7,5,129,63,4,0,0,38,0,0,48,10,2,127,8,8,24,140,130,192,31,20,4,254,160,32,240,7,4,1,0,32,8,0,0,64,0,0,10,2,31,80,16,224,128,0,0,0,0,4,0,16,2,0,0,5,129,63,40,8,252,33,32,96,48,1,1,131,1,16,0,64,64,200,96,2,66,6,35,0,0,128,128,128,193,4,4,12,38,32,96,48,1,1,131,9,8,24,76,64,192,96,130,33,0,0,2,0,0,16,0,0,40,8,124,64,65,224,3,10,2,127,0,16,0,0,128,0,0,130,33,0,160,32,192,1,5,1,14,40,8,0,64,128,0,0,193,16,0,0,1,0,128,0,0,0,130,33,0,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,84,6,0,0,0,0,0,0,26,0,0,0,0,0,0,0,253,255,255,255,255,255,255,255,255,255,211,255,255,254,255,63,248,255,255,255,255,255,255,253,255,255,255,255,255,255,127,248,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,239,255,255,255,254,255,255,255,255,255,255,151,240,255,9,255,159,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127,255,255,247,255,255,255,191,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127,255,255,255,255,255,255,254,255,255,255,255,255,255,255,255,240,255,15,255,255,255,127,9,255,151,240,255,255,255,191,240,255,11,255,255,255,255,255,255,255,255,255,11,255,255,255,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,15,0,0,0,0,0,89,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,34,148,6,130,161,72,12,0,153,92,158,23,203,210,130,84,50,185,102,47,214,231,40,26,100,114,1,95,44,26,82,52,76,52,50,185,134,47,152,104,23,244,38,26,153,92,205,87,162,145,201,5,80,138,70,38,92,0,166,104,100,114,1,150,153,136,144,74,68,35,26,153,0,0,0,162,145,169,40,26,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,13,0,0,0,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,32,0,0,0,0,0,8,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,128,0,0,0,0,0,0,0,2,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,64,0,0,16,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,128,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,8,0,0,0,0,64,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,32,0,0,0,0,0,4,0,0,0,0,128,0,0,0,32,0,0,0,0,128,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,8,0,0,0,0,32,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,139,8,0,0,0,0,0,0,35,0,0,0,0,0,0,0,1,0,0,16,0,0,0,0,0,0,8,0,0,128,4,0,0,1,0,0,8,134,0,0,0,0,0,0,0,0,0,2,0,0,12,0,0,0,0,0,32,24,2,0,0,1,0,0,64,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,48,0,0,0,0,0,0,0,128,128,144,193,4,4,12,38,32,96,48,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,38,0,0,48,0,0,96,8,8,24,12,0,0,0,0,0,0,0,0,0,0,4,0,0,32,0,0,0,64,0,0,0,0,3,0,0,224,128,0,0,0,0,4,0,16,0,0,0,0,0,0,0,0,0,32,32,96,48,1,1,131,1,16,0,64,64,200,96,2,66,6,35,0,0,128,128,128,193,4,4,12,6,0,0,0,0,0,0,0,0,0,64,64,192,96,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,128,0,0,0,0,0,0,1,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,128,137,61,163,135,3,12,112,253,47,1,0,0,0,0,0,44,0,0,0,27,0,0,0,0,2,0,];

    #[allow(dead_code)]
    pub fn parse<'lexer, 'input: 'lexer>(
        lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>)
          -> (::std::option::Option<Result<String, ()>>, ::std::vec::Vec<::lrpar::LexParseError<lrlex::lexemes::DefaultLexeme, u32>>)
    {
        let (grm, stable) = ::lrpar::ctbuilder::_reconstitute(__GRM_DATA, __STABLE_DATA);
        #[allow(clippy::type_complexity)]
        let actions: ::std::vec::Vec<&dyn Fn(::cfgrammar::RIdx<u32>,
                       &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                       ::lrpar::Span,
                       ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                       ())
                    -> __GtActionsKind<'input>> = ::std::vec![&__gt_wrapper_0,
                        &__gt_wrapper_1,
                        &__gt_wrapper_2,
                        &__gt_wrapper_3,
                        &__gt_wrapper_4,
                        &__gt_wrapper_5,
                        &__gt_wrapper_6,
                        &__gt_wrapper_7,
                        &__gt_wrapper_8,
                        &__gt_wrapper_9,
                        &__gt_wrapper_10,
                        &__gt_wrapper_11,
                        &__gt_wrapper_12,
                        &__gt_wrapper_13,
                        &__gt_wrapper_14,
                        &__gt_wrapper_15,
                        &__gt_wrapper_16,
                        &__gt_wrapper_17,
                        &__gt_wrapper_18,
                        &__gt_wrapper_19,
                        &__gt_wrapper_20,
                        &__gt_wrapper_21,
                        &__gt_wrapper_22,
                        &__gt_wrapper_23,
                        &__gt_wrapper_24,
                        &__gt_wrapper_25,
                        &__gt_wrapper_26,
                        &__gt_wrapper_27,
                        &__gt_wrapper_28,
                        &__gt_wrapper_29,
                        &__gt_wrapper_30,
                        &__gt_wrapper_31,
                        &__gt_wrapper_32,
                        &__gt_wrapper_33,
                        &__gt_wrapper_34,
                        &__gt_wrapper_35,
                        &__gt_wrapper_36,
                        &__gt_wrapper_37,
                        &__gt_wrapper_38,
                        &__gt_wrapper_39,
                        &__gt_wrapper_40,
                        &__gt_wrapper_41,
                        &__gt_wrapper_42,
                        &__gt_wrapper_43];

        match ::lrpar::RTParserBuilder::new(&grm, &stable)
            .recoverer(::lrpar::RecoveryKind::CPCTPlus)
            .parse_actions(lexer, &actions, ()) {
                (Some(__GtActionsKind::Ak1(x)), y) => (Some(x), y),
                (None, y) => (None, y),
                _ => unreachable!()
        }
    }

    #[allow(dead_code)]
    pub const R_PROGRAMA: u32 = 1;
    #[allow(dead_code)]
    pub const R_PROGRAMA2: u32 = 2;
    #[allow(dead_code)]
    pub const R_VARS: u32 = 3;
    #[allow(dead_code)]
    pub const R_VARS2: u32 = 4;
    #[allow(dead_code)]
    pub const R_BLOQUE: u32 = 5;
    #[allow(dead_code)]
    pub const R_ESTATUTOS: u32 = 6;
    #[allow(dead_code)]
    pub const R_ESTATUTO: u32 = 7;
    #[allow(dead_code)]
    pub const R_CONDICION: u32 = 8;
    #[allow(dead_code)]
    pub const R_ASIGNACION: u32 = 9;
    #[allow(dead_code)]
    pub const R_ESCRITURA: u32 = 10;
    #[allow(dead_code)]
    pub const R_ESCRITURA2: u32 = 11;
    #[allow(dead_code)]
    pub const R_TIPO: u32 = 12;
    #[allow(dead_code)]
    pub const R_EXPRESION: u32 = 13;
    #[allow(dead_code)]
    pub const R_EXP: u32 = 14;
    #[allow(dead_code)]
    pub const R_CMP: u32 = 15;
    #[allow(dead_code)]
    pub const R_TERMINO: u32 = 16;
    #[allow(dead_code)]
    pub const R_FACTOR: u32 = 17;
    #[allow(dead_code)]
    pub const R_FACTOR2: u32 = 18;
    #[allow(dead_code)]
    pub const R_VARCTE: u32 = 19;
    const __GT_EPP: &[::std::option::Option<&str>] = &[Some("PROGRAM"), Some("ID"), Some("SEMICOLON"), Some("VAR"), Some("COMMA"), Some("COLON"), Some("LEFTBRACKET"), Some("RIGTHBRACKET"), Some("IF"), Some("LEFTPARENTHESES"), Some("RIGHTPARENTHESES"), Some("ELSE"), Some("EQUALSIGN"), Some("PRINT"), Some("CTESTR"), Some("INT"), Some("FLOAT"), Some("PLUSSIGN"), Some("MINUSSIGN"), Some("GREATERSIGN"), Some("LESSSIGN"), Some("NOTEQUALSIGN"), Some("MULTIPLICATIONSIGN"), Some("DIVISIONSIGN"), Some("CTEI"), Some("CTEF"), None];

    /// Return the %epp entry for token `tidx` (where `None` indicates "the token has no
    /// pretty-printed value"). Panics if `tidx` doesn't exist.
    #[allow(dead_code)]
    pub fn token_epp<'a>(tidx: ::cfgrammar::TIdx<u32>) -> ::std::option::Option<&'a str> {
        __GT_EPP[usize::from(tidx)]
    }

    // Wrappers

    fn __gt_wrapper_0<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak2(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak1(__gt_action_0(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_1<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak2(__gt_action_1(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_2<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak3(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak2(__gt_action_2(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_3<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak3(__gt_action_3(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_4<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_4(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_5<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak12(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak4(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_5(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5))
    }

    fn __gt_wrapper_6<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak12(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak4(__gt_action_6(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_7<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak6(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak5(__gt_action_7(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_8<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak5(__gt_action_8(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_9<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak7(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak6(__gt_action_9(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_10<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak6(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak7(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak6(__gt_action_10(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_11<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak9(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_11(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_12<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak8(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_12(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_13<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak10(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak7(__gt_action_13(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_14<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_6 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak8(__gt_action_14(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5, __gt_arg_6))
    }

    fn __gt_wrapper_15<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_6 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_7 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak5(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_8 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak8(__gt_action_15(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5, __gt_arg_6, __gt_arg_7, __gt_arg_8))
    }

    fn __gt_wrapper_16<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak9(__gt_action_16(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4))
    }

    fn __gt_wrapper_17<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_4 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_5 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak10(__gt_action_17(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3, __gt_arg_4, __gt_arg_5))
    }

    fn __gt_wrapper_18<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_18(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_19<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak13(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_19(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_20<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_20(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_21<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak11(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak11(__gt_action_21(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_22<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak12(__gt_action_22(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_23<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak12(__gt_action_23(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_24<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak13(__gt_action_24(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_25<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak15(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak13(__gt_action_25(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_26<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_26(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_27<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_27(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_28<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak14(__gt_action_28(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_29<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_29(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_30<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_30(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_31<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak15(__gt_action_31(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_32<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_32(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_33<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_33(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_34<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak17(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak16(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak16(__gt_action_34(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_35<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak14(x)) => x,
            _ => unreachable!()
        };
        let __gt_arg_3 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak17(__gt_action_35(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2, __gt_arg_3))
    }

    fn __gt_wrapper_36<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak18(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak17(__gt_action_36(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_37<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_37(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_38<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_38(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_39<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        let __gt_arg_2 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::ActionType(__GtActionsKind::Ak19(x)) => x,
            _ => unreachable!()
        };
        __GtActionsKind::Ak18(__gt_action_39(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1, __gt_arg_2))
    }

    fn __gt_wrapper_40<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_40(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_41<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_41(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_42<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let __gt_arg_1 = match __gt_args.next().unwrap() {
            ::lrpar::parser::AStackType::Lexeme(l) => {
                if l.faulty() {
                    Err(l)
                } else {
                    Ok(l)
                }
            },
            ::lrpar::parser::AStackType::ActionType(_) => unreachable!()
        };
        __GtActionsKind::Ak19(__gt_action_42(__gt_ridx, __gt_lexer, __gt_span, (), __gt_arg_1))
    }

    fn __gt_wrapper_43<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                      __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                      __gt_span: ::lrpar::Span,
                      mut __gt_args: ::std::vec::Drain<::lrpar::parser::AStackType<lrlex::lexemes::DefaultLexeme, __GtActionsKind<'input>>>,
                      _: ())
                   -> __GtActionsKind<'input> {
        let _ = ();
        unreachable!()
    }

    #[allow(dead_code)]
    enum __GtActionsKind<'input> {
        Ak1(Result<String, ()>),
        Ak2(Result<String, ()>),
        Ak3(Result<String, ()>),
        Ak4(Result<String, ()>),
        Ak5(Result<String, ()>),
        Ak6(Result<String, ()>),
        Ak7(Result<String, ()>),
        Ak8(Result<String, ()>),
        Ak9(Result<String, ()>),
        Ak10(Result<String, ()>),
        Ak11(Result<String, ()>),
        Ak12(Result<String, ()>),
        Ak13(Result<String, ()>),
        Ak14(Result<String, ()>),
        Ak15(Result<String, ()>),
        Ak16(Result<String, ()>),
        Ak17(Result<String, ()>),
        Ak18(Result<String, ()>),
        Ak19(Result<String, ()>),
    ___GtActionsKindHidden(::std::marker::PhantomData<&'input ()>)
    }


// User code from the program section


    // User actions

    // Programa
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_0<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_4: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Programa2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_1<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Programa2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_2<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_3<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_4<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_5<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Vars2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_6<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Bloque
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_7<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Bloque
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_8<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatutos
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_9<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatutos
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_10<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_11<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_12<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Estatuto
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_13<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Condicion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_14<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>,
                     mut __gt_arg_6: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Condicion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_15<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: Result<String, ()>,
                     mut __gt_arg_6: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_7: Result<String, ()>,
                     mut __gt_arg_8: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Asignacion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_16<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_17<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>,
                     mut __gt_arg_4: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_5: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_18<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_19<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_20<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Escritura2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_21<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Tipo
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_22<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Tipo
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_23<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Expresion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_24<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Expresion
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_25<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_26<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_27<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Exp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_28<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_29<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_30<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Cmp
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_31<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_32<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_33<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Termino
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_34<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>,
                     mut __gt_arg_2: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_3: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_35<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>,
                     mut __gt_arg_3: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_36<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_37<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_38<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Factor2
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_39<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>,
                     mut __gt_arg_2: Result<String, ()>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_40<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_41<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

    // Varcte
    #[allow(clippy::too_many_arguments)]
    fn __gt_action_42<'lexer, 'input: 'lexer>(__gt_ridx: ::cfgrammar::RIdx<u32>,
                     __gt_lexer: &'lexer dyn ::lrpar::NonStreamingLexer<'input, lrlex::lexemes::DefaultLexeme, u32>,
                     __gt_span: ::lrpar::Span,
                     _: (),
                     mut __gt_arg_1: ::std::result::Result<lrlex::lexemes::DefaultLexeme, lrlex::lexemes::DefaultLexeme>)
                 -> Result<String, ()> {
        let _ = ();
Ok("".to_string())
    }

}


/* CACHE INFORMATION
   Build time: "2022-03-09T17:18:18.811614+00:00"
   Grammar path: Some("/Users/diegogarciarodriguezdelcampo/Desktop/8vo/Compis/LittleDuck2020/GRMTOOLS/littleduck/src/littleduck.y")
   Mod name: None
   Recoverer: CPCTPlus
   YaccKind: Some(Grmtools)
   Visibility: ""
   Error on conflicts: true
   0 'PROGRAM'
   1 'ID'
   2 'SEMICOLON'
   3 'VAR'
   4 'COMMA'
   5 'COLON'
   6 'LEFTBRACKET'
   7 'RIGTHBRACKET'
   8 'IF'
   9 'LEFTPARENTHESES'
   10 'RIGHTPARENTHESES'
   11 'ELSE'
   12 'EQUALSIGN'
   13 'PRINT'
   14 'CTESTR'
   15 'INT'
   16 'FLOAT'
   17 'PLUSSIGN'
   18 'MINUSSIGN'
   19 'GREATERSIGN'
   20 'LESSSIGN'
   21 'NOTEQUALSIGN'
   22 'MULTIPLICATIONSIGN'
   23 'DIVISIONSIGN'
   24 'CTEI'
   25 'CTEF'
   26 <unknown>
*/
